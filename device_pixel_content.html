<!DOCTYPE html>
<title>devicePixelContentBox</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
    main {
        position: relative;
        width: 100%;
        height: 50vh;
    }

    .dpcb,
    .gbcr {
        outline: 1px solid black;
    }

    .dpcb {
        position: absolute;
        top: 0;
        left: 0;
        width: 50%;
        height: 10vh;
    }

    .gbcr {
        position: absolute;
        top: 25vh;
        left: 0;
        width: 50%;
        height: 10vh;
    }

    .dpcb:before {
        content: 'ResizeObserver';
        position: absolute;
        top: 0;
        left: 0;
    }

    #error {
        font-weight: bold;
        color: red;
        margin: 1em 0;
    }
</style>
<h1>devicePixelContentBox</h1>
<p>
    <code>ResizeObserver</code> has a new property in Chrome 84+ called<code>devicePixelContentBox</code>, that allows
    you to create pixel-perfect canvases. This is important as off-by-one pixel errors with browser-internal
    pixel-snapping can lead to unpleasant MoirÃ© effects.
</p>
<p>
    Read more in the <a href="https://web.dev/blog/not-published-yet">article</a> on web.dev.
</p>
<p>
    This demo may not be suitable for people prone to photosensitive epilepsy.
    <button>Start</button>
</p>
<div id="error"></div>
<main>
    <canvas class="dpcb"></canvas>
    <canvas class="gbcr"></canvas>
</main>

<script type="module">
    const gbcr = document.querySelector(".gbcr");
    const dpcb = document.querySelector(".dpcb");
    const gbcrCtx = gbcr.getContext("2d");
    const dpcbCtx = dpcb.getContext("2d");
    const texture = generateTexture(2048);

    console.log(gbcr.width)
    console.log(gbcr.height)

    async function main() {

        const startTime = performance.now();
        const speed = 2000;

        requestAnimationFrame(function f(ts) {
            // Calculate the underlying number of *real* pixels covered by the gbcr canvas
            // and size the buffer for the canvas accordingly.
            const cssSize = gbcr.getBoundingClientRect();
            gbcr.width = cssSize.width * devicePixelRatio;
            gbcr.height = cssSize.height * devicePixelRatio;
            draw(gbcrCtx, "getBoundingClientRect");

            const timeElapsed = ts - startTime;
            const time = timeElapsed % speed;
            dpcb.style.top = `${50 +
                Math.sin((timeElapsed / speed) * 2 * Math.PI) * 50}px`;
            gbcr.style.top = `calc(25vh + ${50 +
                Math.sin((timeElapsed / speed) * 2 * Math.PI) * 50}px)`;
            dpcb.style.left = gbcr.style.left = `${50 +
                Math.cos((timeElapsed / speed) * 2 * Math.PI) * 50}px`;
            dpcb.style.width = gbcr.style.width = `calc(50% + ${50 +
                Math.cos((timeElapsed / speed) * 2 * Math.PI) * 50}px)`;
            dpcb.style.height = gbcr.style.height = `calc(10vh + ${50 +
                Math.cos((timeElapsed / speed) * 2 * Math.PI) * 50}px)`;
            requestAnimationFrame(f);
        });

        if (!(await hasDPCBsupport())) {
            document.querySelector("#error").innerHTML +=
                "Your browser does not support the <code>devicePixelContentBox</code> property on <code>ResizeObserver</code> yet. Please try this demo in Chrome Canary.<br>";
            return;
        }
        const observer = new ResizeObserver(entries => {
            // Calculate the underlying number of *real* pixels covered by the dpcb canvas
            // using the new ResizeObserve property.
            const pixelSize = entries.find(entry => entry.target === dpcb).devicePixelContentBoxSize[0];
            dpcb.width = pixelSize.inlineSize;
            dpcb.height = pixelSize.blockSize;
            console.log("called observer")

            draw(dpcbCtx, "ResizeObserver");
        });
        observer.observe(dpcb, { box: ["device-pixel-content-box"] });
    }
    document.querySelector("button").onclick = main;

    function draw(ctx, name) {
        ctx.save()
        ctx.putImageData(texture, 0, 0);
        ctx.textBaseline = "top";
        ctx.font = "24px sans-serif";
        const m = ctx.measureText(name);
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, m.width, 24);
        ctx.fillStyle = "black";
        ctx.fillText(name, 0, 0);
        ctx.restore()
    }

    function hasDPCBsupport() {
        return new Promise(resolve => {
            if (!("ResizeObserver" in self)) {
                return resolve(false);
            }
            const ro = new ResizeObserver(entries => {
                resolve(entries.every(entry => "devicePixelContentBoxSize" in entry));
                ro.disconnect();
            });
            ro.observe(document.body, { box: ["device-pixel-content-box"] });
        });
    }

    function generateTexture(size) {
        const buffer = new Uint8ClampedArray(size * size * 4);
        // Opaque white
        buffer.fill(255);
        // Traverse over the image in 2x2 blocks
        for (let y = 0; y < size; y += 2) {
            for (let x = 0; x < size; x += 2) {
                {
                    const offset = (y * size + x) * 4;
                    buffer[offset + 0] = 0;
                    buffer[offset + 1] = 0;
                    buffer[offset + 2] = 0;
                }
                {
                    const offset = (y * size + x + 1) * 4;
                    buffer[offset + 0] = 255;
                    buffer[offset + 1] = 0;
                    buffer[offset + 2] = 0;
                }
                {
                    const offset = ((y + 1) * size + x) * 4;
                    buffer[offset + 0] = 0;
                    buffer[offset + 1] = 255;
                    buffer[offset + 2] = 0;
                }
                {
                    const offset = ((y + 1) * size + (x + 1)) * 4;
                    buffer[offset + 0] = 255;
                    buffer[offset + 1] = 255;
                    buffer[offset + 2] = 0;
                }
            }
        }
        return new ImageData(buffer, size, size);
    }
</script>