<!DOCTYPE html>
<html>

<head>
    <title>HUPLACLIP experiment</title>
    <script type="text/javascript" src="../graphs_functions.js"></script>
    <script type="text/javascript" src="../experiment_parameters.js"></script>
    <!-- Compressing json files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.11/pako.min.js"></script>

</head>

<style>
    /* styling can be modified here */
</style>

<body>

    <script type="module">

        console.log(currentExperiment)

        // GRAPHS INDICES EXTRACTION (only for the folders of the first 3 clique levels):
        function extractIndicesReduced() {
            /* INPUT:
            - none
        
            OUTPUT:
            - indices of the graphs that will be shown during the experiment
        
            ARRAY STRUCTURE: 
            [ experiment
                [  block1: [ trial1 {graph1} {graph2} ] [ trial 2 {graph1} {graph2} ] ... [trial 30 {graph1} {graph2} ] ]
                [  block2: [ trial1 {graph1} {graph2} ] [ trial 2 {graph1} {graph2} ] ... [trial 30 {graph1} {graph2} ] ]
                ...
                [  block6: [ trial1 {graph1} {graph2} ] [ trial 2 {graph1} {graph2} ] ... [trial 30 {graph1} {graph2}] ]        
            ]
        
            */

            // objects that will contain the indices of the graphs to show for each clique size
            let graphsIndices = {}

            let uniqueCliqueSizesReduced = currentExperiment.uniqueCliqueSizes.slice(0, 3)

            // in the whole exp: for each clique size, 12 graphs with clique and 12 without (2 graphs per block * 6 blocks)
            uniqueCliqueSizesReduced.forEach(element => {
                // creating array of numbers from 1 to 100:
                let arr = Array.from(
                    { length: 100 },
                    (_, index) => index + 1
                );

                // for each clique size, shuffling the array, extracting the first 12 indices and inserting them in the object:
                graphsIndices[element] = shuffleNodes(arr.slice()).slice(0, 12)

            });

            console.log(graphsIndices)

            return graphsIndices

        }


        // Function to read a compressed file and return a Promise
        function readCompressedGraphFile(url) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.responseType = 'arraybuffer';

                xhr.onload = function () {
                    if (xhr.status === 200) {
                        // File successfully loaded
                        const compressedData = new Uint8Array(xhr.response);

                        // Decompress the data using pako
                        const decompressedData = pako.inflate(compressedData, { to: 'string' });

                        // Parse the decompressed JSON data
                        const graph = JSON.parse(decompressedData);
                        resolve(graph);
                    } else {
                        // File loading failed
                        reject(new Error(`Failed to load file: ${url}`));
                    }
                };

                xhr.onerror = function () {
                    reject(new Error(`Failed to load file: ${url}`));
                };

                xhr.open('GET', url, true);
                xhr.send();
            });
        }


        // Async function to read the graph files
        async function readGraphFiles() {

            let uniqueCliqueSizesReduced = currentExperiment.uniqueCliqueSizes.slice(0, 3)

            /* extract indices of graphs to display */
            let graphsWithCliqueIndices = extractIndicesReduced()
            let graphsWithoutCliqueIndices = extractIndicesReduced()

            /* generating names of graphs to display and storing them in currentExperiment object  */
            // empty array that will contain the couples of triangular matrices (objects) to be displayed
            let graphsToDisplay = [];

            // number of blocks:
            for (let blockIndex = 0; blockIndex < currentExperiment.numberOfBlocks; blockIndex++) {

                let graphsForCurrentBlock = []

                for (const element of uniqueCliqueSizesReduced) {

                    // GRAPH WITH CLIQUE, trial 1:
                    // - creating URL:
                    let graphWithClique_trial1_url = `CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithCliqueIndices[element][blockIndex * 2].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_CLIQUE.json`
                    // GRAPH WITHOUT CLIQUE, trial 1:
                    // - creating URL:            
                    let graphWithoutClique_trial1_url = `NO_CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithoutCliqueIndices[element][blockIndex * 2].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_NOCLIQUE.json`

                    // Start reading the files in the background
                    const [graphWithClique1, graphWithoutClique1] = await Promise.all([
                        readCompressedGraphFile(graphWithClique_trial1_url),
                        readCompressedGraphFile(graphWithoutClique_trial1_url)
                    ]);

                    // Adding the two graphs to the array for the current trial (random choice of which one is the first in the couple) and pushing this array into the array relative to the current block
                    if (Math.round(Math.random())) {
                        graphsForCurrentBlock.push([graphWithClique1, graphWithoutClique1])
                    } else {
                        graphsForCurrentBlock.push([graphWithoutClique1, graphWithClique1])
                    }

                    // GRAPH WITH CLIQUE, trial 2:
                    // - creating URL:
                    let graphWithClique_trial2_url = `CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithCliqueIndices[element][blockIndex * 2 + 1].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_CLIQUE.json`
                    // GRAPH WITHOUT CLIQUE, trial 2:
                    // - creating URL:            
                    let graphWithoutClique_trial2_url = `NO_CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithoutCliqueIndices[element][blockIndex * 2 + 1].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_NOCLIQUE.json`

                    // Start reading the files in the background
                    const [graphWithClique2, graphWithoutClique2] = await Promise.all([
                        readCompressedGraphFile(graphWithClique_trial2_url),
                        readCompressedGraphFile(graphWithoutClique_trial2_url)
                    ]);


                    // Adding the two graphs to the array for the current trial (random choice of which one is the first in the couple) and pushing this array into the array relative to the current block
                    if (Math.round(Math.random())) {
                        graphsForCurrentBlock.push([graphWithClique2, graphWithoutClique2])
                    } else {
                        graphsForCurrentBlock.push([graphWithoutClique2, graphWithClique2])
                    }
                }

                // adding array of graphs for current block to array of all graphs
                graphsToDisplay.push(graphsForCurrentBlock)

                console.log("finished reading graphs for block number: " + blockIndex)


            }

            console.log("finished reading graphs")
            // adding array of graphs to display to currentExperiment object:
            console.log(graphsToDisplay)

        }


        // trying function:
        let graphsToDisplay = readGraphFiles()
        console.log(graphsToDisplay)


    </script>

</body>

</html>