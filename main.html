<!DOCTYPE html>
<html>
  <head>
    <title>New version of HUPLACLIP</title>
    <!-- My scripts -->
    <script src="graphs_generation.js"></script>
    <script src="instructions/instructions_generation.js"></script>
    <script src="experiment_parameters.js"></script>
    <!-- Standard scripts -->
    <script src="jspsych/dist/jspsych.js"></script>    
    <script src="jspsych/dist/jspsych.js"></script>
    <!-- Plugins -->
    <script src="jspsych/dist/plugin-canvas-keyboard-response.js"></script>
    <script src="jspsych/dist/plugin-instructions.js"></script>
    <link href="jspsych/dist/jspsych.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <script type="module">

        /* initialize jsPsych */
        var jsPsych = initJsPsych({
            on_finish: function() {
            console.log("experiment is over")
            jsPsych.data.displayData();
            }
        });

        /* create timeline */
        var timeline = [];

        /* INTRODUCTION (informed consent + instructions + tutorial??) */
        let introduction = {
        type: jsPsychInstructions,
        pages: generateIntroductionPages(),
        show_clickable_nav: true    //subjects will be able to navigate through the pages
        }
        timeline.push(introduction)
        

        /* DRAWING STIMULI: create separate js file? */
            // FUNCTION THAT WILL DRAW THE STIMULI GIVEN THE CHOSEN ORDER OF THE NODES:
            function generateDrawStimuli(presentationIndex) {
                /* INPUT: 
                - presentationIndex (the number that identifies the couple of graphs that is being displayed)
                - orderOfNodes (the order with which the nodes will be displayed)

                OUTPUT:
                - display of the stimuli on the screen
                */    

                // function that generates the stimuli:
                function drawStimuli(c) {

                    // addressing canvas
                    let ctx = c.getContext("2d"); 

                    // for each presentation, shuffling the standard order of the nodes (adding "slice()" so that the value of "currentExperiment.standardOrderOfNodes" is not modified):
                    let currentTrialOrder = shuffleNodes(currentExperiment.standardOrderOfNodes.slice())
                    // global variable that temporarily stores the order of the nodes (it keeps changing, and its value is read from plugin to store the order in the corresponding trial)
                    jsPsych.data.presentedOrder = currentTrialOrder
                    // global variable that temporarily stores the current size of the clique (it keeps changing, and its value is read from plugin to store the order in the corresponding trial)
                    jsPsych.data.cliqueSize = currentExperiment.arrayOfCliqueSizes[presentationIndex]

                    // global variable that temporarily stores the correct answer for the current presentation (it keeps changing, and its value is read from plugin to store the order in the corresponding trial)
                    if(currentExperiment.graphsToDisplay[presentationIndex][0][currentExperiment.numberOfNodes] == "clique is absent") 
                        //if first stimulus doesn't have the clique, then the graph with the clique is on the right side
                        jsPsych.data.correctResponse = "arrowright"
                     else
                        jsPsych.data.correctResponse = "arrowleft"

                    // calculating step size for the figure (each square contains two "steps", for this reason multiplying the number of nodes by 2):
                    let singleStepSize = ((9/10)*(c.height))/(((Object.keys(currentExperiment.standardOrderOfNodes).length)*2)) // Object.keys(currentExperiment.standardOrderOfNodes).length --> number of squares
                    // calculating starting points (for right and left stimulus) on x axis (considering the space to be left in the middle):
                    let xStartingPointLeft = (c.width/2 ) - c.width/20
                    let xStartingPointRight = (c.width/2 ) + c.width/20
                    let yStartingPoint = (1/20)*(c.height)  //NB: starting to draw not from top of window, but leaving (1/20*c.height) above (and consequently below). For this reason, the single step size is calculated dividing not (c.height) but (9/10*canvas.height)
                  
            
                    // Drawing stimulus on LEFT side:
                    // accessing the graph that will appear on the left side of the screen:
                    let leftGraph = currentExperiment.graphsToDisplay[presentationIndex][0]       
                    //storing the associations for node number 0 in a separate array (to facilitate accessibility):
                    let leftNodeZeroAssociations = []
                    for (let rowIndex = 0; rowIndex < (Object.values(leftGraph).length - 1); rowIndex++) {
                       //first element of each row of triangular graph represent the associations for node "0"
                        leftNodeZeroAssociations.push(Object.values(leftGraph)[rowIndex][0])
                        //NB: first element represents existence of association between node "0" and node "1" and so on
                    } 

                    for (let firstIndex = 0; firstIndex < ((currentExperiment.standardOrderOfNodes.length)-1); firstIndex++) {
                        for (let secondIndex = 0; secondIndex < firstIndex+1; secondIndex++) {
                            // drawing the square
                            ctx.beginPath();
                            ctx.moveTo(xStartingPointLeft-singleStepSize*(firstIndex-secondIndex+1),yStartingPoint+singleStepSize*(firstIndex+secondIndex)); //starting point (top angle)
                            ctx.lineTo(xStartingPointLeft-singleStepSize*(firstIndex-secondIndex),yStartingPoint+singleStepSize*(firstIndex+secondIndex+1)); //going left-right (right angle)
                            ctx.lineTo(xStartingPointLeft-singleStepSize*(firstIndex-secondIndex+1),yStartingPoint+singleStepSize*(firstIndex+secondIndex+2)); //going down-left (bottom angle)
                            ctx.lineTo(xStartingPointLeft-singleStepSize*(firstIndex-secondIndex+2),yStartingPoint+singleStepSize*(firstIndex+secondIndex+1)); //going up-left (left angle)
                            ctx.lineTo(xStartingPointLeft-singleStepSize*(firstIndex-secondIndex+1),yStartingPoint+singleStepSize*(firstIndex+secondIndex)); //closing square (top angle) (same coordinates of starting point)

                            // defining the outline
                            ctx.lineWidth = .8;
                            ctx.strokeStyle = '#666666';
                            ctx.stroke();

                            ctx.fillStyle = "#FFFFFF";
                            ctx.fill();   

                            // Determining whether the two nodes are associated:
                            let presentAssociation = false // will be changed to "true" if association is present in the considered instance 
                            // when dealing with associations for node "0", using the array created at the beginning of the function:
                            if (currentTrialOrder[firstIndex+1] == 0 ) {
                                //first node was zero
                                if(leftNodeZeroAssociations[(currentTrialOrder[secondIndex])-1] == 1 )
                                    presentAssociation = true
                            } else if (currentTrialOrder[secondIndex] == 0) {
                                //second node was zero
                                if(leftNodeZeroAssociations[(currentTrialOrder[firstIndex+1])-1] == 1 )            
                                    presentAssociation = true
                            } else {
                                // when dealing with non-zero nodes, always reading the value from bigger node (constraint because of triangular matrix)
                                //console.log("no zeros between the two nodes. Is the association present? ")
                                if (currentTrialOrder[firstIndex+1] < currentTrialOrder[secondIndex]) {
                                    //second element is bigger
                                    if(leftGraph[currentTrialOrder[secondIndex]][currentTrialOrder[firstIndex+1]] == 1)
                                        presentAssociation = true
                                } else {
                                    //second element is smaller
                                    if(leftGraph[currentTrialOrder[firstIndex+1]][currentTrialOrder[secondIndex]] == 1)
                                        presentAssociation = true
                                }
                            }
                                
                            //filling the square according to the choice just made
                            if (presentAssociation) {
                                // black if nodes are associated
                                ctx.fillStyle = "#000000";
                                ctx.fill();
                            } else {
                                // white if nodes are unassociated
                                ctx.fillStyle = "#FFFFFF";
                                ctx.fill();                       
                                }
                            }
                            
                        }

                     
                    // Drawing stimulus on RIGHT side:
                    // accessing the graph that will appear on the left side of the screen:
                    let rightGraph = currentExperiment.graphsToDisplay[presentationIndex][1]
                    //console.log(rightGraph)       
                    //storing the associations for node number 0 in a separate array (to facilitate accessibility):
                    let rightNodeZeroAssociations = []
                    for (let rowIndex = 0; rowIndex < (Object.values(rightGraph).length - 1); rowIndex++) {
                       //first element of each row of triangular graph represent the associations for node "0"
                        rightNodeZeroAssociations.push(Object.values(rightGraph)[rowIndex][0])
                        //NB: first element represents existence of association between node "0" and node "1" and so on
                    } 
                                        
                    for (let firstIndex = 0; firstIndex < ((currentExperiment.standardOrderOfNodes.length)-1); firstIndex++) {
                        for (let secondIndex = 0; secondIndex < firstIndex+1; secondIndex++) {
                            // drawing the square
                            ctx.beginPath();
                            ctx.moveTo(xStartingPointRight+singleStepSize*(firstIndex-secondIndex+1),yStartingPoint+singleStepSize*(firstIndex+secondIndex)); //starting point (top angle)
                            ctx.lineTo(xStartingPointRight+singleStepSize*(firstIndex-secondIndex),yStartingPoint+singleStepSize*(firstIndex+secondIndex+1)); //going left-right (right angle)
                            ctx.lineTo(xStartingPointRight+singleStepSize*(firstIndex-secondIndex+1),yStartingPoint+singleStepSize*(firstIndex+secondIndex+2)); //going down-left (bottom angle)
                            ctx.lineTo(xStartingPointRight+singleStepSize*(firstIndex-secondIndex+2),yStartingPoint+singleStepSize*(firstIndex+secondIndex+1)); //going up-left (left angle)
                            ctx.lineTo(xStartingPointRight+singleStepSize*(firstIndex-secondIndex+1),yStartingPoint+singleStepSize*(firstIndex+secondIndex)); //closing square (top angle) (same coordinates of starting point)

                            // defining the outline
                            ctx.lineWidth = .8;
                            ctx.strokeStyle = '#666666';
                            ctx.stroke();

                            ctx.fillStyle = "#FFFFFF";
                            ctx.fill();   

                            // Determining whether the two nodes are associated:
                            let presentAssociation = false // will be changed to "true" if association is present in the considered instance 
                            // when dealing with associations for node "0", using the array created at the beginning of the function:
                            if (currentTrialOrder[firstIndex+1] == 0 ) {
                                //first node was zero
                                if(rightNodeZeroAssociations[(currentTrialOrder[secondIndex])-1] == 1 )
                                    presentAssociation = true
                            } else if (currentTrialOrder[secondIndex] == 0) {
                                //second node was zero
                                if(rightNodeZeroAssociations[(currentTrialOrder[firstIndex+1])-1] == 1 )            
                                    presentAssociation = true
                            } else {
                                // when dealing with non-zero nodes, always reading the value from bigger node (constraint because of triangular matrix)
                                //console.log("no zeros between the two nodes. Is the association present? ")
                                if (currentTrialOrder[firstIndex+1] < currentTrialOrder[secondIndex]) {
                                    //second element is bigger
                                    if(rightGraph[currentTrialOrder[secondIndex]][currentTrialOrder[firstIndex+1]] == 1)
                                        presentAssociation = true
                                } else {
                                    //second element is smaller
                                    if(rightGraph[currentTrialOrder[firstIndex+1]][currentTrialOrder[secondIndex]] == 1)
                                        presentAssociation = true
                                }
                            }
                                
                            //filling the square according to the choice just made
                            if (presentAssociation) {
                                // black if nodes are associated
                                ctx.fillStyle = "#000000";
                                ctx.fill();
                            } else {
                                // white if nodes are unassociated
                                ctx.fillStyle = "#FFFFFF";
                                ctx.fill();                       
                                }
                            }
                            
                        }

                    
                    // ADDING ACCURACY on the top-right corner of the screen
                    // accessing the array of the trials done up to now:
                    let currentTrialsArray = jsPsych.data.get().trials
                    let arrayOfResponses = []
                    // looping through all the elements to check which trials have a final response (arrow press):
                    currentTrialsArray.forEach(element => {
                        // only the trials were arrow press was done have the "correctnessOfResponse" property
                        if(element.hasOwnProperty('correctnessOfResponse') )
                            // if(element.correctnessOfResponse)
                                // correctResponses += 1 
                            arrayOfResponses.push(element.correctnessOfResponse)
                    });
                    let numberOfCorrectResponses = arrayOfResponses.reduce((a, b) => a + b, 0)
                    //creating string to be displayed as feedback:
                    let feedbackString = "SCORE: " + numberOfCorrectResponses +"/"+ presentationIndex
                    //rect (differentiating color (green / red) based on correctness / incorrectness of last response)
                    if(arrayOfResponses.length == 0)
                        // if no response has been given, choosing a "neutral" color
                        ctx.fillStyle = "orange";
                    else 
                        if(arrayOfResponses[arrayOfResponses.length-1] == true)
                            ctx.fillStyle = "lawngreen";
                        else
                            ctx.fillStyle = "red";
                    ctx.fillRect((c.width-(c.width/6)), (c.height)/16, 200, 80);
                    // text on the canvas:
                    ctx.fillStyle = "black"
                    ctx.font = "bold 1.7em system-ui";
                    ctx.fillText(feedbackString, (c.width-(c.width/6.5)), (c.height)/7.5);

                    }
                
                return drawStimuli

            }
            

    /* ACTUAL JSPSYCH SCRIPT: */
        // creating the trials for the experiment
        for (let presentationIndex = 0; presentationIndex < currentExperiment.numberOfPresentations; presentationIndex++) {
            
            // defining the current trial
            let currentTrial = {
            type: jsPsychCanvasKeyboardResponse, 
            canvas_size: [currentExperiment.canvasDimensions[0], currentExperiment.canvasDimensions[1]], // [height,width]
            // prompt: '<p> Which of the two matrices contains the clique? <br> Press the left arrow to indicate the left one, press the right arrow to indicate the right one. <br> Press Spacebar to reorder the nodes of the two graphs </p>',
            choices: [' ', 'ArrowLeft','ArrowRight'],
            response_ends_trial: true,
            timeline: [],
            data: {
                // other parameters for the exp go here
                presentationNumber: presentationIndex, //NB: one trial is a couple of graphs presented on the screen
                }  
            }
      
            // adding the stimulus to the timeline of the trial
            // NB: shuffling is done inside draw function
            currentTrial.timeline.push({stimulus: generateDrawStimuli(presentationIndex)})

            // repeating the trial until an answer on the buttons is given:
            let loop_node = {
            timeline: [currentTrial],
            loop_function: function(data){
                // accessing the data stored up to now (it will increase progressively):
                let currentData = jsPsych.data.get()

                if (currentData.trials.filter(element => element.presentationNumber == presentationIndex).length == currentExperiment.maximumNumberOfRandomizations) {
                    // if number of repetitions exceeded the limit for the current stimulus, moving to next stimulus:
                    console.log("maximum number of randomizations for this trial, moving on to the next one")
                    return false
                }  else if(currentData.last(1).values()[0].response == " "){
                    // if last response was a spacebar press, repeat the trial
                    return true 
                } else if(currentData.last(1).values()[0].response == 0 || currentData.last(1).values()[0].response == 1) {
                    // if last response was on left/right arrow, moving to next trial
                    console.log("arrow clicked, moving to next trial")
                    return false 
                }
            }
            } 
            
            // adding the loop node to the timeline
            timeline.push(loop_node)
        
        }

        /* start the experiment */
        jsPsych.run(timeline);

    </script>

</body>
</html>