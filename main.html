<!DOCTYPE html>
<html>
  <head>
    <title>New version of HUPLACLIP</title>
    <script src="jspsych/dist/jspsych.js"></script>
    <script src="jspsych/dist/plugin-canvas-button-response.js"></script>
    <link href="jspsych/dist/jspsych.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <script type="module">

        /* initialize jsPsych */
        var jsPsych = initJsPsych({
            on_finish: function() {
            console.log("experiment is over")
            console.log(jsPsych.data);
            }
        });

        /* create timeline */
        var timeline = [];

        // defining inputs and building the currentExperiment object:
        // In this version: 
        // - N fixed, C fixed
        // - Only one stimulus (with clique) is generated and modified throughout the exp
        let numberOfStimuli = 2; // number of stimuli to be shown
        let numberOfTrialsForEachStimulus = 4; // number of presentation of each stimulus (number of modifications allowed before providing a response)
        let numberOfNodes = 30;
        let cliqueSize = 20;       
        //determining number of stimuli with and without clique:
        let numberOfStimuliWithClique = Math.round(numberOfStimuli/2)
        let numberOfStimuliWithoutClique = Math.round(numberOfStimuli/2)
        //if numberOfStimuli is odd -> removing one trial without clique (less relevant for experiment)
        if (numberOfStimuli % 2 != 0) {
            numberOfStimuliWithoutClique -= 1
        }

        //creating array that contains the indices of all the nodes of the graph in the standard order
        let nodesArray = new Array();
        for (let index = 0; index < numberOfNodes; index++) {
            nodesArray.push(index)
        }

        // instantiating object for current experiment:
        const currentExperiment = {
            // parameters for experiment
            numberOfStimuli: numberOfStimuli, // number of stimuli to be shown
            numberOfTrialsForEachStimulus: numberOfTrialsForEachStimulus, // number of presentation of each stimulus (number of modifications allowed before providing a response)
            numberOfStimuliWithClique: numberOfStimuliWithClique,
            numberOfStimuliWithoutClique: numberOfStimuliWithoutClique,            
            // parameters for single graphs
            numberOfNodes: numberOfNodes,
            probabilityOfAssociation: 0.5, // by default nodes are associated with probability .5 (can be changed manually from here)
            cliqueSize: cliqueSize,       
            nodesArray: nodesArray
        }


        // FUNCTION THAT ASSOCIATES THE NODES THAT WILL BE PART OF THE CLIQUE (adapted from: https://stackoverflow.com/questions/19269545/how-to-get-a-number-of-random-elements-from-an-array)
        function createClique(nodesArray, cliqueSize) {
            /* INPUT:
            - array that contains all the nodes in the graph
            - size of the clique

            OUTPUT:
            - array of nodes that will be part of the clique
            */
            let result = new Array(cliqueSize),
            len = nodesArray.length,
            taken = new Array(len);
            while (cliqueSize--) {
                let x = Math.floor(Math.random() * len);
                result[cliqueSize] = nodesArray[x in taken ? taken[x] : x];
                taken[x] = --len in taken ? taken[len] : len;
            }
            return result;
        }


        // FUNCTION THAT SWAPS TWO ELEMENTS IN AN ARRAY GIVEN THEIR INDICES (adapted from: https://www.freecodecamp.org/news/swap-two-array-elements-in-javascript/)
        const swapElements = (array, index1, index2) => {
            /* INPUT:
            - array that contains the order in which the nodes have been drawn in this visualization of the stimulus
            - indices of the two nodes to be swapped

            OUTPUT:
            - array where the nodes at the specified indices have been swapped
            */
            [array[index1], array[index2]] = [array[index2], array[index1]];
        };
        


        //FUNCTION THAT GENERATES THE GRAPHS THAT WILL BE DISPLAYED
        function generateGraphs(currentExperiment) {            
            /* INPUT: 
            - currentExperiment object (with specifics of the experiment)

            OUTPUT:
            - array of all the triangular matrices that will be displayed in the experiment (NB: triangular matrices are represented as objects)
            */

            /* Visual representation of the single output triangular matrix object (example: N=5. NB: number of nodes start from zero):
            0|    -
            1|   1 -
            2|   0 1 -
            3|   1 0 0 -
            4|   0 0 1 0 -
                ___________
                 0 1 2 3 4  

                Corresponding object:
                { 
                  1: [1],
                  2: [0 1],
                  3: [1 0 0],
                  4: [0 0 1 0]
                }
            */

            // generating empty array that will be filled with the objects to be displayed:
            let graphsToDisplay = [];
            // generating stimuli with clique:
            for (let index = 0; index < currentExperiment.numberOfStimuliWithClique; index++) {
                //empty object (the properties will be the nodes and the values will be the arrays that indicate the existing connections)
                let currentTriangularMatrix = {};
                // randomly extracting the nodes that will be part of the clique
                let cliqueArray = [];
                cliqueArray = createClique(currentExperiment.nodesArray,currentExperiment.cliqueSize)       
                // defining the values of the triangular adjacency matrix:
                for (let rowIndex = 1; rowIndex < currentExperiment.numberOfNodes; rowIndex++) {
                    //instantiating empty array that will contain the connections for the current row
                    let currentRowAssociations = [];
                    for (let columnIndex = 0; columnIndex < rowIndex; columnIndex++) {  
                        if (cliqueArray.includes(rowIndex) && cliqueArray.includes(columnIndex)) {
                            //if clique has to be present and current two nodes are part of the clique, inserting 1 in the matrix:
                            currentRowAssociations.push(1)
                            }
                        //if the current two nodes are not part of the clique, associating them with probability indicated in "currentExperiment.probabilityOfAssociation"
                        else {
                            let randomValue = Math.random();
                            if(randomValue < currentExperiment.probabilityOfAssociation){
                                currentRowAssociations.push(1);
                            } else {
                                currentRowAssociations.push(0);
                            }
                        }
                    } 
                //adding to the matrix an indication about the presence of the clique:
                currentTriangularMatrix[currentExperiment.numberOfNodes] = "clique array for current stimulus is: " + cliqueArray                
                //adding to the object the property (the connections of the current node in the triangular matrix)
                currentTriangularMatrix[rowIndex] = currentRowAssociations;
                }
            // adding the current object to the array of graphs to be displayed
            graphsToDisplay.push(currentTriangularMatrix)    
            }

            // generating stimuli without clique:
            for (let index = 0; index < currentExperiment.numberOfStimuliWithoutClique; index++) {
                //empty object (the properties will be the nodes and the values will be the arrays that indicate the existing connections)
                let currentTriangularMatrix = {};     
                // defining the values of the triangular adjacency matrix:
                for (let rowIndex = 1; rowIndex < currentExperiment.numberOfNodes; rowIndex++) {
                    //instantiating empty array that will contain the connections for the current row
                    let currentRowAssociations = [];
                    for (let columnIndex = 0; columnIndex < rowIndex; columnIndex++) {  
                        let randomValue = Math.random();
                        if(randomValue < currentExperiment.probabilityOfAssociation){
                            currentRowAssociations.push(1);
                        } else {
                            currentRowAssociations.push(0);
                        }
                    }
                // adding to the matrix an indication about the absence of the clique:
                currentTriangularMatrix[currentExperiment.numberOfNodes] = "clique is absent"
                //adding to the object the property (the connections of the current node in the triangular matrix)
                currentTriangularMatrix[rowIndex] = currentRowAssociations;               
                } 
            // adding the current object to the array of graphs to be displayed
            graphsToDisplay.push(currentTriangularMatrix)
            }                

        return graphsToDisplay

        }

        
        // FUNCTION THAT WILL DRAW THE STIMULUS AND STORE IN THE DATA THE NEW ORDERING OF THE NODES CHOSEN BY THE SUBJECT:
        function generateDrawStimuliWithChoice(triangularMatrix,stimulusIndex) {
            /* INPUT: 
            - triangularMatrix: single triangular matrix to be visualized on the screen
            - singleTrialData: element that stores the additional data for the present trial

            OUTPUT:
            - 
            */    

            // function that generates the stimuli:
            function drawStimuliWithChoice(c) {

                // addressing canvas
                let ctx = c.getContext("2d"); 

                // calculating step size for the figure (some margin is needed to draw the buttons for node 0 (on the right) and last node (on the left), for this reason increasing the number of nodes by 2):
                let singleStepSize = c.width/(((Object.keys(triangularMatrix).length)*2)+2) // Object.keys(triangularMatrix).length --> number of squares to be drawn
                // calculating starting point on x axis (considering the margin to be left at the right-side of the figure):
                let xStartingPoint = c.width - singleStepSize
                // calculating starting point on y axis (considering the margin to be left under the figure):
                let yStartingPoint = c.height - singleStepSize

                if (jsPsych.data.pressedButtons == undefined || jsPsych.data.get().trials.filter(element => element.stimulusNumber == stimulusIndex).length == 0) {
                    // if this is the first visualization ever or the first visualization of a certain stimulus, drawing the stimuli with standard order
                    console.log("showing stimulus with standard order, which is: ")
                    // initializing the variable that stores the order of nodes (since first visualization, it has to be the standard order):
                    let initialOrdering = currentExperiment.nodesArray.sort()
                    jsPsych.data.orderOfNodes = initialOrdering 
                    console.log( jsPsych.data.orderOfNodes )           

                    for (let firstIndex = 0; firstIndex < Object.keys(triangularMatrix).length-1; firstIndex++) {
                        for (let secondIndex = 0; secondIndex < firstIndex+1; secondIndex++) {
                            // drawing the square
                            ctx.beginPath();
                            ctx.moveTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //starting point (right angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize*(firstIndex-secondIndex)); //going left-down (bottom angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+2),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //going up-left (left angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize*(firstIndex-secondIndex+2)); //going up-right (upper angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //closing square (right angle) (same coordinates of starting point)

                            // defining the outline
                            ctx.lineWidth = .5;
                            ctx.strokeStyle = '#666666';
                            ctx.stroke();
                            
                            // filling with the appropriate colour
                            if (triangularMatrix[firstIndex+1][secondIndex] == 1) {
                                // black if nodes are associated
                                ctx.fillStyle = "#000000";
                                ctx.fill();
                            } else {
                                // white if nodes are unassociated
                                ctx.fillStyle = "#FFFFFF";
                                ctx.fill();                       
                            }
                        }
                    }

                } else {   

                    swapElements(jsPsych.data.orderOfNodes,jsPsych.data.pressedButtons[0],jsPsych.data.pressedButtons[1])
                    console.log("order of nodes for next trial: ")
                    console.log(jsPsych.data.orderOfNodes)
                    
                    // if buttons have been pressed, drawing the stimulus accordingly
                    for (let firstIndex = 0; firstIndex < Object.keys(triangularMatrix).length-1; firstIndex++) {
                        for (let secondIndex = 0; secondIndex < firstIndex+1; secondIndex++) {
                            // drawing the square
                            ctx.beginPath();
                            ctx.moveTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //starting point (right angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize*(firstIndex-secondIndex)); //going left-down (bottom angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+2),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //going up-left (left angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize*(firstIndex-secondIndex+2)); //going up-right (upper angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //closing square (right angle) (same coordinates of starting point)

                            // defining the outline
                            ctx.lineWidth = .5;
                            ctx.strokeStyle = '#666666';
                            ctx.stroke();
                            
                            // filling with the appropriate colour
                            if (triangularMatrix[firstIndex+1][secondIndex] == 1) {
                                // black if nodes are associated
                                ctx.fillStyle = "#0000ff";
                                ctx.fill();
                            } else {
                                // white if nodes are unassociated
                                ctx.fillStyle = "#FFFFFF";
                                ctx.fill();                       
                            }
                        }
                    }

                }                

                // drawing the buttons:
                let buttonsCoordinates = []
                for (let firstIndex = 0; firstIndex < Object.keys(triangularMatrix).length; firstIndex++) {
                    for (let secondIndex = 0; secondIndex <= firstIndex+1; secondIndex++) {
                        if (firstIndex == secondIndex) {
                            let singleButtonCoordinates = [] //TO DO: CONVERT TO INTEGER? MORE READABLE
                            // drawing the button and appending its coordinates to "singleButtonCoordinates":
                            ctx.beginPath();
                            //1
                            ctx.lineTo(c.width-singleStepSize*(firstIndex+secondIndex),yStartingPoint); //starting point (right angle of button, corresponds to bottom angle of last drawn square)
                            singleButtonCoordinates.push(c.width-singleStepSize*(firstIndex+secondIndex),yStartingPoint)
                            //2
                            ctx.lineTo(c.width-singleStepSize*(firstIndex+secondIndex+1),c.height); //going left-down (bottom angle of button; y coordinate: end of canvas)
                            singleButtonCoordinates.push(c.width-singleStepSize*(firstIndex+secondIndex+1),c.height)
                            //3
                            ctx.lineTo(c.width-singleStepSize*(firstIndex+secondIndex+2),yStartingPoint); //going up-left (left angle of button)
                            singleButtonCoordinates.push(c.width-singleStepSize*(firstIndex+secondIndex+2),yStartingPoint)
                            //4
                            ctx.lineTo(c.width-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize); //going up-right (top angle of button, corresponds to left angle of last drawn square)
                            singleButtonCoordinates.push(c.width-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize)
                            //5
                            ctx.lineTo(c.width-singleStepSize*(firstIndex+secondIndex),yStartingPoint); //closing square (right angle) (same coordinates of starting point)
                            // defining the outline
                            ctx.lineWidth = 50/(Object.keys(triangularMatrix).length); // setting the width of the line so it decreases for high number of nodes
                            ctx.strokeStyle = '#009933'; // green outline
                            ctx.stroke();
                            // defining the fill color
                            ctx.fillStyle = "#990000";
                            ctx.fill();

                            //adding this button to "buttonsCoordinates":
                            buttonsCoordinates.push(singleButtonCoordinates)
                        }
                    }
                }

                // adding the coordinates of the buttons to the data, so that they will be accessible:
                jsPsych.data.buttonsCoordinates = buttonsCoordinates
                
                // after each trial, adding an empty array that will store the swapped buttons (added from the plugin):
                jsPsych.data.pressedButtons = []

                }
            
            return drawStimuliWithChoice
        
        }
        

        // generating all the stimuli to be drawn (TO DO: GLOBAL VARIABLE (no input to generateDrawStimuli...) ):
        let stimuliArray = generateGraphs(currentExperiment)
        console.log(stimuliArray)

        // defining canvas width and calculating canvas height (positioning is defined in the CSS):
        let canvasWidth = 1200  //to be changed from here
        let canvasHeight = (canvasWidth/5)*3

        // creating the trials for the experiment
        for (let stimulusIndex = 0; stimulusIndex < currentExperiment.numberOfStimuli; stimulusIndex++) {
            
            // defining the current trial
            let currentTrial = {
            type: jsPsychCanvasButtonResponse, 
            canvas_size: [canvasHeight, canvasWidth], // [height,width]
            prompt: '<p>Is the clique present? <br> Select two red buttons to modify the stimulus, trying to group together the black pixels</p>',
            choices: ['No', 'Yes'],
            response_ends_trial: true,
            timeline: [],
            data: {
                // other parameters for the exp go here
                stimulusNumber: stimulusIndex,
                // nextOrderOfNodes: jsPsych.data.getLastTrialData().trials[0].nextOrderOfNodes   
                }   
            }            

            
            // adding the stimulus to the timeline of the trial
            currentTrial.timeline.push({stimulus: generateDrawStimuliWithChoice(stimuliArray[stimulusIndex],stimulusIndex)})
        
            // repeating the trial until an answer on the buttons is given:
            let loop_node = {
            timeline: [currentTrial],
            loop_function: function(data){
                // accessing the data stored up to now (it will increase progressively):
                let currentData = jsPsych.data.get()
                if (currentData.trials.filter(element => element.stimulusNumber == stimulusIndex).length == currentExperiment.numberOfTrialsForEachStimulus) {
                    // if number of repetitions exceeded the limit for the current stimulus, moving to next stimulus:
                    console.log("maximum number of repetitions for the stimulus, moving on to the next one")
                    return false
                }  else if(currentData.last(1).values()[0].response == 2){
                    // if last trial was a reordering, present the next trial
                    return true 
                } else if(currentData.last(1).values()[0].response == 0 || currentData.last(1).values()[0].response == 1) {
                    // if click was on a button (0="no"; 1="yes"), go to next stimulus
                    console.log("click on button, moving to next stimulus")
                    return false 
                }
            }
            } 
            
            // adding the loop node to the timeline
            timeline.push(loop_node)
        
        }

        /* start the experiment */
        jsPsych.run(timeline);

    </script>

</body>
</html>