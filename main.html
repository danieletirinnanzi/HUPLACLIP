<!DOCTYPE html>
<html>
  <head>
    <title>New version of HUPLACLIP</title>
    <script src="jspsych/dist/jspsych.js"></script>
    <script src="jspsych/dist/plugin-canvas-button-response.js"></script>
    <script src="jspsych/dist/plugin-canvas-keyboard-response.js"></script>
    <link href="jspsych/dist/jspsych.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <script type="module">

        /* initialize jsPsych */
        var jsPsych = initJsPsych({
            on_finish: function() {
            console.log("experiment is over")
            jsPsych.data.displayData();
            }
        });

        /* create timeline */
        var timeline = [];

        /*TO ADD: INSTRUCTIONS (with "plugin-instructions.js" or "plugin-html-keyboard-response.js"), recover from ethics committee file */

        // defining canvas width and calculating canvas height (positioning is defined in the CSS):
        // POSSIBLE MODIFICATION -> MAKING DIMENSIONS RELATIVE TO SCREEN SIZE?
        //let canvasWidth = 1200  //to be changed from here
        //let canvasHeight = (canvasWidth/5)*3

        // CREATING OBJECT FOR CURRENT EXPERIMENT:
        const currentExperiment = {
            // parameters for experiment:
            numberOfTrials: 22, // number of trials for each experiment (singe trial = single couple of triangular matrices, presented once and reordered through space bar presses)
            numberOfRandomizations: 3, // maximum number of randomizations allowed for a single couple of matrices 
            canvasDimensions: [700,1000], // [height,width]
            // parameters for graphs:
            numberOfNodes: 200,
            initialCliqueSize: 100,  // this is the maximum dimension of the clique, it will decrease throughout the experiment, increasing the difficulty of the task                       
            probabilityOfAssociation: 0.5
        }

        // FUNCTION THAT DEFINES THE CLIQUE SIZE FOR ALL THE TRIALS THAT WILL BE PRESENTED (implementation of "linspace", but stored in reverse order)
        function createArrayOfCliqueSizes(initialCliqueSize, numberOfTrials) {
            /* INPUT:
            - initial clique size (maximum value of the clique, the next values will be lower)
            - number of trials for the experiment

            OUTPUT:
            - array where the dimension of the clique for each one of the trials is stored in the order of presentation
            */            
            let cliqueSizeArray = [];
            let step = initialCliqueSize / (numberOfTrials);
            for (let i = 0; i < numberOfTrials; i++) {
                cliqueSizeArray.push(Math.round(initialCliqueSize - (step * i)));
            }
            return cliqueSizeArray;
        }

        //creating array that contains the indices of all the nodes of the graph in the standard order
        let standardOrderArray = new Array();
        for (let index = 0; index < currentExperiment.numberOfNodes; index++) {
            standardOrderArray.push(index)
        }
        // adding this array as a property to the "currentExperiment" object
        currentExperiment.standardOrderOfNodes = standardOrderArray

        // creating array that contains the clique sizes and adding it as a property to "currentExperiment" object
        currentExperiment.arrayOfCliqueSizes = createArrayOfCliqueSizes(currentExperiment.initialCliqueSize,currentExperiment.numberOfTrials)


        // FUNCTION THAT ASSOCIATES THE NODES THAT WILL BE PART OF THE CLIQUE (adapted from: https://stackoverflow.com/questions/19269545/how-to-get-a-number-of-random-elements-from-an-array)
        function createClique(nodesArray, singleCliqueSize) {
            /* INPUT:
            - array that contains all the nodes in the graph
            - size of the clique

            OUTPUT:
            - array of nodes that will be part of the clique
            */
            let result = new Array(singleCliqueSize),
            len = nodesArray.length,
            taken = new Array(len);
            while (singleCliqueSize--) {
                let x = Math.floor(Math.random() * len);
                result[singleCliqueSize] = nodesArray[x in taken ? taken[x] : x];
                taken[x] = --len in taken ? taken[len] : len;
            }
            return result;
        }

        
        // FUNCTION THAT GENERATES A SINGLE PERMUTATION OF THE NODES GIVEN AS INPUT (RIVEDI E RINOMINA LE VARIABILI) (adapted from: https://stackoverflow.com/questions/9960908/permutations-in-javascript)
        function permuteNodes(input) {
        let i, ch;
        for (i = 0; i < input.length; i++) {
            ch = input.splice(i, 1)[0];
            usedChars.push(ch);
            if (input.length == 0) {
            permArr.push(usedChars.slice());
            }
            permute(input);
            input.splice(i, 0, ch);
            usedChars.pop();
        }
        return permArr
        };


        //FUNCTION THAT GENERATES ALL THE COUPLES OF GRAPHS (one with clique, one without) THAT WILL BE DISPLAYED
        function generateGraphs() {            
            /* INPUT: none ("currentExperiment" is global and can be accessed from inside functions)

            OUTPUT:
            - array of all the couples of triangular matrices that will be displayed in the experiment (NB: triangular matrices are represented as objects)
            */

            /* Visual representation of a single triangular matrix object (example: N=5. NB: number of nodes start from zero):
            0|    -
            1|   1 -
            2|   0 1 -
            3|   1 0 0 -
            4|   0 0 1 0 -
                ___________
                 0 1 2 3 4  

                Corresponding object:
                { 
                  1: [1],
                  2: [0 1],
                  3: [1 0 0],
                  4: [0 0 1 0]
                }
            */

            // empty array that will contain the couples of triangular matrices (objects) to be displayed
            let couplesOfGraphsToDisplay = [];
            for (let index = 0; index < currentExperiment.numberOfTrials; index++) {
                // for each trail, generate a couple of graphs, one with clique and one without, stored in an array:
                let singleCoupleOfGraphs = []

                // 1. Generating graph with clique:
                //empty object (the properties will be the nodes and the values will be the arrays that indicate the existing connections)
                let graphWithClique = {};
                // randomly extracting the nodes that will be part of the clique
                let cliqueArray = [];
                cliqueArray = createClique(currentExperiment.standardOrderOfNodes,currentExperiment.arrayOfCliqueSizes[index])       
                // defining the values of the triangular adjacency matrix:
                for (let rowIndex = 1; rowIndex < currentExperiment.numberOfNodes; rowIndex++) {
                    //instantiating empty array that will contain the connections for the current row
                    let currentRowAssociations = [];
                    for (let columnIndex = 0; columnIndex < rowIndex; columnIndex++) {  
                        if (cliqueArray.includes(rowIndex) && cliqueArray.includes(columnIndex)) {
                            //if current two nodes are part of the clique, inserting 1 in the matrix:
                            currentRowAssociations.push(1)
                            }
                        //if the current two nodes are not part of the clique, associating them with probability indicated in "currentExperiment.probabilityOfAssociation"
                        else {
                            let randomValue = Math.random();
                            if(randomValue < currentExperiment.probabilityOfAssociation){
                                currentRowAssociations.push(1);
                            } else {
                                currentRowAssociations.push(0);
                            }
                        }
                    } 
                //adding to the matrix an indication about the presence of the clique:
                graphWithClique[currentExperiment.numberOfNodes] = "clique array for current stimulus is: " + cliqueArray                
                //adding to the object the property (the connections of the current node in the triangular matrix)
                graphWithClique[rowIndex] = currentRowAssociations;
                }

                // 2. Generating graph without clique:
                //empty object (the properties will be the nodes and the values will be the arrays that indicate the existing connections)
                let graphWithoutClique = {};     
                // defining the values of the triangular adjacency matrix:
                for (let rowIndex = 1; rowIndex < currentExperiment.numberOfNodes; rowIndex++) {
                    //instantiating empty array that will contain the connections for the current row
                    let currentRowAssociations = [];
                    for (let columnIndex = 0; columnIndex < rowIndex; columnIndex++) {  
                        let randomValue = Math.random();
                        if(randomValue < currentExperiment.probabilityOfAssociation){
                            // !! TO DO HERE: MATCHING THE DEGREE DISTRIBUTION OF THE GRAPH WITH THE CLIQUE??
                            currentRowAssociations.push(1);
                        } else {
                            currentRowAssociations.push(0);
                        }
                    }
                // adding to the matrix an indication about the absence of the clique:
                graphWithoutClique[currentExperiment.numberOfNodes] = "clique is absent"
                //adding to the object the property (the connections of the current node in the triangular matrix)
                graphWithoutClique[rowIndex] = currentRowAssociations;               
                } 

                // Adding the two graphs to the array for the current trial (the order is chosen randomly)
                if (Math.round(Math.random())) {
                    // DEBUG
                    console.log("putting the array with clique before")
                    couplesOfGraphsToDisplay.push( [ graphWithClique, graphWithoutClique ] )
                } else {
                    console.log("putting the array withOUT clique before")
                    couplesOfGraphsToDisplay.push( [ graphWithoutClique, graphWithClique ] )
                } 
            }              

        return couplesOfGraphsToDisplay

        }

        
        // FUNCTION THAT WILL DRAW THE STIMULI GIVEN THE CHOSEN ORDER OF THE NODES:
        // !!! IMPORTANT TO MAKE THINGS SIMPLER !! -> DRAW STARTING FROM ORDER OF NODES
        function generateDrawStimuli(trialIndex,orderOfNodes) {
            /* INPUT: 
            - trialIndex (the number that identifies the couple of graphs that is being displayed)
            - orderOfNodes (the order with which the ndoes whould be displayed)

            OUTPUT:
            - display of the stimuli on the screen
            */    

            // function that generates the stimuli:
            function drawStimuli(c) {

                // addressing canvas
                let ctx = c.getContext("2d"); 

                // - DEFINING IDEAL SHAPE OF CANVAS (square/rectangle)
                // - CALCULATING STEP SIZE AND STARTING POINTS (X/Y)
                // - DRAWING THE SQUARES AND FILLING THEM WITH APPROPRIATE COLOR BASED ON  currentExperiment.graphsToDisplay[stimulusIndex] -> gives the two graphs to be displayed, with the nodes ordered as in "orderOfNodes" (input)
                // - DRAWING ACCURACY (feedback) ON TOP-RIGHT CORNER OF THE CANVAS
                // - RIVEDI FUNZIONE permuteNodes() E CONTROLLA CHE FUNZIONI PER BENE

                // calculating step size for the figure (some margin is needed to draw the buttons for node 0 (on the right) and last node (on the left), for this reason increasing the number of nodes by 2):
                let singleStepSize = c.width/(((Object.keys(triangularMatrix).length)*2)+2) // Object.keys(triangularMatrix).length --> number of squares to be drawn
                // calculating starting point on x axis (considering the margin to be left at the right-side of the figure):
                let xStartingPoint = c.width - singleStepSize
                // calculating starting point on y axis (considering the margin to be left under the figure):
                let yStartingPoint = c.height - singleStepSize

                if (jsPsych.data.pressedButtons == undefined || jsPsych.data.get().trials.filter(element => element.stimulusNumber == trialIndex).length == 0) {
                    // if this is the first visualization ever or the first visualization of a certain stimulus, drawing the stimuli with standard order
                    console.log("showing stimulus with standard order, which is: ")
                    // initializing the variable that stores the order of nodes (since first visualization, it has to be the standard order):
                    let initialOrdering = currentExperiment.nodesArray.sort()
                    jsPsych.data.orderOfNodes = initialOrdering 
                    console.log( jsPsych.data.orderOfNodes )           

                    for (let firstIndex = 0; firstIndex < Object.keys(triangularMatrix).length-1; firstIndex++) {
                        for (let secondIndex = 0; secondIndex < firstIndex+1; secondIndex++) {
                            // drawing the square
                            ctx.beginPath();
                            ctx.moveTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //starting point (right angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize*(firstIndex-secondIndex)); //going left-down (bottom angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+2),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //going up-left (left angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize*(firstIndex-secondIndex+2)); //going up-right (upper angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //closing square (right angle) (same coordinates of starting point)

                            // defining the outline
                            ctx.lineWidth = .5;
                            ctx.strokeStyle = '#666666';
                            ctx.stroke();
                            
                            // filling with the appropriate colour
                            if (triangularMatrix[firstIndex+1][secondIndex] == 1) {
                                // black if nodes are associated
                                ctx.fillStyle = "#000000";
                                ctx.fill();
                            } else {
                                // white if nodes are unassociated
                                ctx.fillStyle = "#FFFFFF";
                                ctx.fill();                       
                            }
                        }
                    }

                } else {   

                    swapElements(jsPsych.data.orderOfNodes,jsPsych.data.pressedButtons[0],jsPsych.data.pressedButtons[1])
                    console.log("order of nodes for next trial: ")
                    console.log(jsPsych.data.orderOfNodes)
                    
                    // if buttons have been pressed, drawing the stimulus accordingly
                    for (let firstIndex = 0; firstIndex < Object.keys(triangularMatrix).length-1; firstIndex++) {
                        for (let secondIndex = 0; secondIndex < firstIndex+1; secondIndex++) {
                            // drawing the square
                            ctx.beginPath();
                            ctx.moveTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //starting point (right angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize*(firstIndex-secondIndex)); //going left-down (bottom angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+2),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //going up-left (left angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize*(firstIndex-secondIndex+2)); //going up-right (upper angle)
                            ctx.lineTo(xStartingPoint-singleStepSize*(firstIndex+secondIndex),yStartingPoint-singleStepSize*(firstIndex-secondIndex+1)); //closing square (right angle) (same coordinates of starting point)

                            // defining the outline
                            ctx.lineWidth = .5;
                            ctx.strokeStyle = '#666666';
                            ctx.stroke();
                            
                            // filling with the appropriate colour
                            if (triangularMatrix[firstIndex+1][secondIndex] == 1) {
                                // black if nodes are associated
                                ctx.fillStyle = "#0000ff";
                                ctx.fill();
                            } else {
                                // white if nodes are unassociated
                                ctx.fillStyle = "#FFFFFF";
                                ctx.fill();                       
                            }
                        }
                    }

                }                

                // drawing the buttons:
                let buttonsCoordinates = []
                for (let firstIndex = 0; firstIndex < Object.keys(triangularMatrix).length; firstIndex++) {
                    for (let secondIndex = 0; secondIndex <= firstIndex+1; secondIndex++) {
                        if (firstIndex == secondIndex) {
                            let singleButtonCoordinates = [] //TO DO: CONVERT TO INTEGER? MORE READABLE
                            // drawing the button and appending its coordinates to "singleButtonCoordinates":
                            ctx.beginPath();
                            //1
                            ctx.lineTo(c.width-singleStepSize*(firstIndex+secondIndex),yStartingPoint); //starting point (right angle of button, corresponds to bottom angle of last drawn square)
                            singleButtonCoordinates.push(c.width-singleStepSize*(firstIndex+secondIndex),yStartingPoint)
                            //2
                            ctx.lineTo(c.width-singleStepSize*(firstIndex+secondIndex+1),c.height); //going left-down (bottom angle of button; y coordinate: end of canvas)
                            singleButtonCoordinates.push(c.width-singleStepSize*(firstIndex+secondIndex+1),c.height)
                            //3
                            ctx.lineTo(c.width-singleStepSize*(firstIndex+secondIndex+2),yStartingPoint); //going up-left (left angle of button)
                            singleButtonCoordinates.push(c.width-singleStepSize*(firstIndex+secondIndex+2),yStartingPoint)
                            //4
                            ctx.lineTo(c.width-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize); //going up-right (top angle of button, corresponds to left angle of last drawn square)
                            singleButtonCoordinates.push(c.width-singleStepSize*(firstIndex+secondIndex+1),yStartingPoint-singleStepSize)
                            //5
                            ctx.lineTo(c.width-singleStepSize*(firstIndex+secondIndex),yStartingPoint); //closing square (right angle) (same coordinates of starting point)
                            // defining the outline
                            ctx.lineWidth = 50/(Object.keys(triangularMatrix).length); // setting the width of the line so it decreases for high number of nodes
                            ctx.strokeStyle = '#009933'; // green outline
                            ctx.stroke();
                            // defining the fill color
                            ctx.fillStyle = "#990000";
                            ctx.fill();

                            //adding this button to "buttonsCoordinates":
                            buttonsCoordinates.push(singleButtonCoordinates)
                        }
                    }
                }

                // adding the coordinates of the buttons to the data, so that they will be accessible:
                jsPsych.data.buttonsCoordinates = buttonsCoordinates
                
                // after each trial, adding an empty array that will store the swapped buttons (added from the plugin):
                jsPsych.data.pressedButtons = []

                }



            
            return drawStimuli
        
        }
 
        // adding the graphs to display as a property to the "currentExperiment" object
        currentExperiment.graphsToDisplay = generateGraphs()
        

        // creating the trials for the experiment
        for (let trialIndex = 0; trialIndex < currentExperiment.numberOfTrials; trialIndex++) {
            
            // defining the current trial
            let currentTrial = {
            type: jsPsychCanvasKeyboardResponse, 
            canvas_size: [currentExperiment.canvasDimensions[0], currentExperiment.canvasDimensions[1]], // [height,width]
            prompt: '<p> Which of the two matrices contains the clique? <br> Press the left arrow to indicate the left one, press the right arrow to indicate the right one. <br> Press Spacebar to reorder the nodes of the two graphs </p>',
            choices: [' ', 'ArrowLeft','ArrowRight'],
            response_ends_trial: true,
            timeline: [],
            data: {
                // other parameters for the exp go here
                }   
            }            
      
            // adding the stimulus to the timeline of the trial
            currentTrial.timeline.push({stimulus: generateDrawStimuli(trialIndex,permuteNodes(currentExperiment.standardOrderOfNodes))})
        
            // repeating the trial until an answer on the buttons is given:
            let loop_node = {
            timeline: [currentTrial],
            loop_function: function(data){
                // accessing the data stored up to now (it will increase progressively):
                let currentData = jsPsych.data.get()
                // NEXT STEPS:
                // IF PREVIOUS RESPONSE WAS A BUTTON PRESS, PRESENT THE TRIAL AGAIN WITH A DIFFERENT PERMUTATION OF THE NODES, STORE IT IN A TEMPORARY VARIABLE (jsPsych.data...)
                if (currentData.trials.filter(element => element.stimulusNumber == trialIndex).length == currentExperiment.numberOfTrialsForEachStimulus) {
                    // if number of repetitions exceeded the limit for the current stimulus, moving to next stimulus:
                    console.log("maximum number of repetitions for the stimulus, moving on to the next one")
                    return false
                }  else if(currentData.last(1).values()[0].response == 2){
                    // if last trial was a reordering, present the next trial
                    return true 
                } else if(currentData.last(1).values()[0].response == 0 || currentData.last(1).values()[0].response == 1) {
                    // if click was on a button (0="no"; 1="yes"), go to next stimulus
                    console.log("click on button, moving to next stimulus")
                    return false 
                }
            }
            } 
            
            // adding the loop node to the timeline
            timeline.push(loop_node)
        
        }

        /* start the experiment */
        jsPsych.run(timeline);

    </script>

</body>
</html>