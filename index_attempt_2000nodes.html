<!DOCTYPE html>
<html>

<head>
    <title>HUPLACLIP experiment</title>
    <script type="text/javascript" src="graphs_functions.js"></script>
    <script type="text/javascript" src="experiment_parameters.js"></script>
    <script type="text/javascript" src="canvas_drawing.js"></script>

    <!-- Standard jspsych.js -->
    <script type="text/javascript" src="jspsych/dist/jspsych.js"></script>

    <!-- Standard plugins -->
    <script type="text/javascript" src="jspsych/dist/plugin-instructions.js"></script>
    <script type="text/javascript" src="jspsych/dist/plugin-fullscreen.js"></script>

    <!-- Customized plugin -->
    <script type="text/javascript" src="jspsych/dist/my-plugin-canvas-keyboard-response.js"></script>

    <!-- Compressing json files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.11/pako.min.js"></script>

    <!-- Styling -->
    <link href="jspsych/dist/jspsych.css" rel="stylesheet" type="text/css" />

</head>

<style>
    /* styling can be modified here */
</style>

<body>

    <script type="module">

        console.log(currentExperiment)

        const uniqueCliqueSizesReduced = currentExperiment.uniqueCliqueSizes.slice(0, 3)

        // GRAPHS INDICES EXTRACTION (only for the folders of the first 3 clique levels):
        function extractIndicesReduced() {
            /* INPUT:
            - none
        
            OUTPUT:
            - indices of the graphs that will be shown during the experiment
        
            ARRAY STRUCTURE: 
            [ experiment
                [  block1: [ trial1 {graph1} {graph2} ] [ trial 2 {graph1} {graph2} ] ... [trial 30 {graph1} {graph2} ] ]
                [  block2: [ trial1 {graph1} {graph2} ] [ trial 2 {graph1} {graph2} ] ... [trial 30 {graph1} {graph2} ] ]
                ...
                [  block6: [ trial1 {graph1} {graph2} ] [ trial 2 {graph1} {graph2} ] ... [trial 30 {graph1} {graph2}] ]        
            ]
        
            */

            // objects that will contain the indices of the graphs to show for each clique size
            let graphsIndices = {}

            // in the whole exp: for each clique size, 12 graphs with clique and 12 without (2 graphs per block * 6 blocks)
            uniqueCliqueSizesReduced.forEach(element => {
                // creating array of numbers from 1 to 100:
                let arr = Array.from(
                    { length: 100 },
                    (_, index) => index + 1
                );

                // for each clique size, shuffling the array, extracting the first 12 indices and inserting them in the object:
                graphsIndices[element] = shuffleNodes(arr.slice()).slice(0, 12)

            });

            return graphsIndices

        }


        // Function to read a compressed file and return a Promise
        function readCompressedGraphFile(url) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.responseType = 'arraybuffer';

                xhr.onload = function () {
                    if (xhr.status === 200) {
                        // File successfully loaded
                        const compressedData = new Uint8Array(xhr.response);

                        // Decompress the data using pako
                        const decompressedData = pako.inflate(compressedData, { to: 'string' });

                        // Parse the decompressed JSON data
                        const graph = JSON.parse(decompressedData);
                        resolve(graph);
                    } else {
                        // File loading failed
                        reject(new Error(`Failed to load file: ${url}`));
                    }
                };

                xhr.onerror = function () {
                    reject(new Error(`Failed to load file: ${url}`));
                };

                xhr.open('GET', url, true);
                xhr.send();
            });
        }


        // Async function to read the graph files
        async function readGraphFiles() {

            /* extract indices of graphs to display */
            let graphsWithCliqueIndices = extractIndicesReduced()
            let graphsWithoutCliqueIndices = extractIndicesReduced()

            /* generating names of graphs to display and storing them in currentExperiment object  */
            // empty array that will contain the couples of triangular matrices (objects) to be displayed
            let graphsToDisplay = [];

            // number of blocks:
            for (let blockIndex = 0; blockIndex < currentExperiment.numberOfBlocks; blockIndex++) {

                let graphsForCurrentBlock = []

                for (const element of uniqueCliqueSizesReduced) {

                    // GRAPH WITH CLIQUE, trial 1:
                    // - creating URL:
                    let graphWithClique_trial1_url = `graph_pools/CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithCliqueIndices[element][blockIndex * 2].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_CLIQUE.json`
                    // GRAPH WITHOUT CLIQUE, trial 1:
                    // - creating URL:            
                    let graphWithoutClique_trial1_url = `graph_pools/NO_CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithoutCliqueIndices[element][blockIndex * 2].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_NOCLIQUE.json`

                    // Start reading the files in the background
                    const [graphWithClique1, graphWithoutClique1] = await Promise.all([
                        readCompressedGraphFile(graphWithClique_trial1_url),
                        readCompressedGraphFile(graphWithoutClique_trial1_url)
                    ]);

                    // Adding the two graphs to the array for the current trial (random choice of which one is the first in the couple) and pushing this array into the array relative to the current block
                    if (Math.round(Math.random())) {
                        graphsForCurrentBlock.push([graphWithClique1, graphWithoutClique1])
                    } else {
                        graphsForCurrentBlock.push([graphWithoutClique1, graphWithClique1])
                    }

                    // GRAPH WITH CLIQUE, trial 2:
                    // - creating URL:
                    let graphWithClique_trial2_url = `graph_pools/CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithCliqueIndices[element][blockIndex * 2 + 1].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_CLIQUE.json`
                    // GRAPH WITHOUT CLIQUE, trial 2:
                    // - creating URL:            
                    let graphWithoutClique_trial2_url = `graph_pools/NO_CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithoutCliqueIndices[element][blockIndex * 2 + 1].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_NOCLIQUE.json`

                    // Start reading the files in the background
                    const [graphWithClique2, graphWithoutClique2] = await Promise.all([
                        readCompressedGraphFile(graphWithClique_trial2_url),
                        readCompressedGraphFile(graphWithoutClique_trial2_url)
                    ]);


                    // Adding the two graphs to the array for the current trial (random choice of which one is the first in the couple) and pushing this array into the array relative to the current block
                    if (Math.round(Math.random())) {
                        graphsForCurrentBlock.push([graphWithClique2, graphWithoutClique2])
                    } else {
                        graphsForCurrentBlock.push([graphWithoutClique2, graphWithClique2])
                    }
                }

                // adding array of graphs for current block to array of all graphs
                graphsToDisplay.push(graphsForCurrentBlock)

                console.log("finished reading graphs for block number: " + blockIndex)

            }

            console.log("finished reading graphs")
            // adding array of graphs to display to currentExperiment object:
            currentExperiment.graphsToDisplay = graphsToDisplay

        }

        // CHECKING DEVICE REQUIREMENTS:
        // - vertical resolution is at least 1080px
        if (currentExperiment.canvasDimensions[0] < 1080) alert("The vertical resolution of your device is not sufficient for performing the experiment. Please open it with on a different device.")
        // - browser is different from Safari (does not allow keboard input when in FullScreen mode)
        let isSafari = window.safari !== undefined
        if (isSafari) alert("Please open the experiment in a browser different from Safari.")


        /* initializing jspsych */
        var jsPsych = initJsPsych({

            // maximum width of experiment pages
            experiment_width: currentExperiment.canvasDimensions[1],

            // Audio will be played through HTML5, not through WebAudio API
            use_webaudio: false,

            on_finish: function (data) {
                // displaying data:
                jsPsych.data.displayData();
                // local save:
                let currentDate = new Date();
                let fileName = `HUPLACLIP_pilot_${currentDate.getDate()}.${(currentDate.getMonth() + 1)}.${currentDate.getFullYear()}_${currentDate.getHours()}.${currentDate.getMinutes()}.${currentDate.getSeconds()}.json`
                jsPsych.data.get().localSave('json', fileName);
            }
        });


        /* create timeline */
        let timeline = [];


        /* INTRODUCTIVE PAGES */
        // showing informative pages about the study (informed consent, aim, privacy)
        let introduction = {
            type: jsPsychInstructions,
            pages: ['hi'],
            key_forward: "ArrowRight",
            // call the readGraphFiles function when instructions start:
            on_start: readGraphFiles,
            on_finish: function () {
                // Select the element with class "jspsych-display-element"
                var displayElement = document.querySelector('.jspsych-display-element');
                // Add the style attribute with overflow:hidden to prevent subject from scrolling during experiment
                displayElement.style.overflow = 'hidden';
            }
        }
        timeline.push(introduction)


        // entering FullScreen before experiment:
        var enter_fullscreen = {
            type: jsPsychFullscreen,
            fullscreen_mode: true
        }
        timeline.push(enter_fullscreen)

        /* ACTUAL EXPERIMENT: */

        /* DRAWING STIMULI: */
        // FUNCTION THAT WILL DRAW THE STIMULI GIVEN THE CHOSEN ORDER OF THE NODES:
        function generateDrawCanvas(blockIndex, presentationIndex) {
            /* INPUT: 
            - blockIndex (the number that identifies the current block)
            - presentationIndex (the number that identifies the couple of graphs that is being displayed)
 
            OUTPUT:
            - display of the stimuli on the screen
            */

            // function that generates the stimuli:
            async function drawCanvas(c) {

                // addressing canvas
                let ctx = c.getContext("2d");

                // for each presentation, shuffling the standard order of the nodes (used to draw the stimuli)
                console.log("started shuffling")
                let currentTrialOrder = shuffleNodes(currentExperiment.standardOrderOfNodes.slice())    //using "slice()" so that the value of "currentExperiment.standardOrderOfNodes" is not modified)
                console.log("finished shuffling")

                // accessing the array of the trials completed up to now (used to draw the feedback):
                let currentTrialsArray = jsPsych.data.get().trials

                // DRAWING ON CANVAS:               
                //left stimulus:
                drawStimulus("left", ctx, blockIndex, presentationIndex, currentTrialOrder)
                // right stimulus:
                drawStimulus("right", ctx, blockIndex, presentationIndex, currentTrialOrder)
                // accuracy and number of remaining randomizations:
                drawFeedback(ctx, blockIndex, presentationIndex, currentTrialsArray)
                // instructions reminder:
                drawInstructionsReminder(ctx)

                // GLOBAL VARIABLES ADDED TO TRIAL_DATA (read in "my-plugin-canvas-keyboard-response.js")
                // order of the nodes (changes from trial to trial)
                jsPsych.data.presentedOrder = currentTrialOrder
                // variables that do not change from trial to trial but are used when subject gives final answer:
                // - correct answer (its value is read to compute the "accuracy" variable)
                if (currentExperiment.graphsToDisplay[blockIndex][presentationIndex][0][currentExperiment.graphSize].clique_array == "clique is absent")
                    //if first stimulus doesn't have the clique, then the graph with the clique (correct answer) is on the right side
                    jsPsych.data.correctResponse = "arrowright"
                else
                    jsPsych.data.correctResponse = "arrowleft"
            }

            return drawCanvas

        }


        // creating the blocks of the experiment
        for (let blockIndex = 0; blockIndex < currentExperiment.numberOfBlocks; blockIndex++) {

            // creating the trials for the block
            for (let presentationIndex = 0; presentationIndex < 6; presentationIndex++) {

                // defining the current trial
                let currentTrial = {
                    type: jsPsychCanvasKeyboardResponse,
                    canvas_size: [currentExperiment.canvasDimensions[0], currentExperiment.canvasDimensions[1]], // [height,width]
                    choices: [' ', 'ArrowLeft', 'ArrowRight'],
                    response_ends_trial: true,
                    timeline: [],
                    data: {
                        // storing variables that do not change between trials relative to the same couple of graphs
                        // experiment parameters:
                        block_index: blockIndex,
                        presentation_index: presentationIndex,
                        // graphs parameters:
                        clique_size: currentExperiment.arrayOfCliqueSizes[presentationIndex],
                        graph_size: currentExperiment.graphSize,
                    },
                    on_start: function (currentTrial) {
                        // - when trial starts, graphs have been read:
                        currentTrial.data.graphs_names = [currentExperiment.graphsToDisplay[blockIndex][presentationIndex][0][currentExperiment.graphSize].graph_name, currentExperiment.graphsToDisplay[blockIndex][presentationIndex][1][currentExperiment.graphSize].graph_name]
                        // - accessing the data stored up to now (it will increase progressively):
                        let currentData = jsPsych.data.get()
                        // - if no more shuffles are available, only allowing final answers (arrow presses):
                        if (currentData.trials.filter(element => element.block_index == blockIndex && element.presentation_index == presentationIndex).length == currentExperiment.maximumNumberOfShuffles)
                            currentTrial.choices = ['ArrowLeft', 'ArrowRight']
                    },
                    on_finish: function (data) {
                        // providing audio feedback based on last response (shuffle, correct answer, wrong answer) (ALTERNATIVE: using JSPsych audioKeboard plugin (https://groups.google.com/g/jspsych/c/y0qYDhKVOXw) ):
                        let lastTrial = jsPsych.data.get().last(1).values()[0]
                        let audioFilePath = ''
                        if (lastTrial.response == " ")
                            audioFilePath = 'audio_feedback/shuffles/shuffle01.mp3'
                        else
                            // if final answer, play sound based on correct / wrong answer
                            if (lastTrial.accuracy)
                                audioFilePath = 'audio_feedback/right/coin01.mp3'
                            else
                                audioFilePath = 'audio_feedback/wrong/error01.mp3'
                        let feedbackAudio = new Audio(audioFilePath);
                        feedbackAudio.play();
                    },
                }

                // adding the stimuli to the timeline of the trial
                // NB: shuffling of nodes is done inside draw function
                currentTrial.timeline.push({ stimulus: generateDrawCanvas(blockIndex, presentationIndex) })

                // repeating the trial until a final answer (left/right arrow press) is given:
                let loop_node = {
                    timeline: [currentTrial],
                    loop_function: function () {
                        // accessing the data stored up to now (it will increase progressively):
                        let currentData = jsPsych.data.get()
                        if (currentData.last(1).values()[0].response == " ") {
                            // if last response was a spacebar press, repeat the trial
                            return true
                        } else if (currentData.last(1).values()[0].response == 0 || currentData.last(1).values()[0].response == 1) {
                            // if last response was on left/right arrow, moving to next trial
                            return false
                        }

                    }
                }

                // adding the loop node to the timeline
                timeline.push(loop_node)

            }

            // after each block, present break page
            switch (blockIndex) {
                // if last block just presented, final page will be different
                case (currentExperiment.numberOfBlocks - 1):
                    /* FINAL PAGE */
                    let final_page = {
                        type: jsPsychInstructions,
                        pages: [], // defined inside on_start function (below)
                        key_forward: " ",
                        on_start: function (final_page) {
                            // accessing the array of all the trials completed up to now:
                            let currentTrialsArray = jsPsych.data.get().trials
                            let arrayOfResponsesLastBlock = []  //to compute block score
                            let arrayOfResponses = []   //to compute total score
                            currentTrialsArray.forEach(element => {
                                // creating array of final responses for current block:
                                if (element.block_index == blockIndex && element.hasOwnProperty('accuracy'))
                                    arrayOfResponsesLastBlock.push(element.accuracy)
                                // creating array of all final responses:
                                if (element.hasOwnProperty('accuracy'))
                                    arrayOfResponses.push(element.accuracy)
                            })
                            // computing score:
                            // - last block score:
                            let numberOfCorrectResponsesLastBlock = arrayOfResponsesLastBlock.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponsesLastBlock = arrayOfResponsesLastBlock.length
                            // - total score:
                            let numberOfCorrectResponses = arrayOfResponses.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponses = arrayOfResponses.length
                            // last trial feedaback: changing background color of SCORE based on correctness of last response
                            let scoreColor = "black"
                            if (arrayOfResponsesLastBlock[arrayOfResponsesLastBlock.length - 1]) {
                                scoreColor = "lawngreen"
                            } else {
                                scoreColor = "red"
                            }
                            final_page.pages = [
                                `<p> 
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:${scoreColor};color:black;display:inline-block;">SCORE: ${numberOfCorrectResponsesLastBlock} / ${numberOfFinalResponsesLastBlock}</div>
                                <br><br><br>                             
                                You completed all the <b> ${currentExperiment.numberOfBlocks}</b> blocks of the experiment. <br><br>
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:gold;color:black;display:inline-block;">TOTAL SCORE: ${numberOfCorrectResponses} / ${numberOfFinalResponses}</div>
                                <br><br>
                                Thank you for your time.
                                <br><br>
                                Press <b>space</b> to exit.
                                </p>`]
                        }
                    };
                    timeline.push(final_page)
                    break;
                default:
                    /* AGREEMENT TO MOVE TO NEXT BLOCK */
                    let move_to_next_block = {
                        type: jsPsychInstructions,
                        pages: [], // defined inside on_start function (below)
                        key_forward: " ",
                        on_start: function (move_to_next_block) {
                            // accessing the array of the trials completed up to now:
                            let currentTrialsArray = jsPsych.data.get().trials
                            let arrayOfResponsesPerBlock = []
                            currentTrialsArray.forEach(element => {
                                // creating array of final responses for current block:
                                if (element.block_index == blockIndex && element.hasOwnProperty('accuracy'))
                                    arrayOfResponsesPerBlock.push(element.accuracy)
                            })
                            // calculating accuracy for current block:
                            let numberOfCorrectResponsesPerBlock = arrayOfResponsesPerBlock.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponsesPerBlock = arrayOfResponsesPerBlock.length
                            // last trial feedback: changing background color of SCORE based on correctness of last response
                            let scoreColor = "black"
                            if (arrayOfResponsesPerBlock[arrayOfResponsesPerBlock.length - 1]) {
                                scoreColor = "lawngreen"
                            } else {
                                scoreColor = "red"
                            }
                            move_to_next_block.pages = [
                                `<p> 
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:${scoreColor};color:black;display:inline-block;">SCORE: ${numberOfCorrectResponsesPerBlock} / ${numberOfFinalResponsesPerBlock}</div>
                                    <br><br>
                                    So far, you have completed <b> ${(blockIndex + 1)} </b> out of <b>${currentExperiment.numberOfBlocks}</b> blocks. <br>
                                    You still have <b> ${currentExperiment.numberOfBlocks - (blockIndex + 1)} </b> to go.
                                    <br><br>
                                    Remember: <br>
                                    - Press <b> LEFT / RIGHT arrow </b> to choose the triangle with the hidden red tiles. <br>
                                    - Press <b> SPACE </b> to shuffle the triangles. <br><br>
                                    When you feel ready, press <b>space</b> to move to the next block.
                                  </p>`]
                        }
                    };
                    timeline.push(move_to_next_block)
            }

        }

        // exiting fullscreen after experiment:
        var exit_fullscreen = {
            type: jsPsychFullscreen,
            fullscreen_mode: false,
            delay_after: 0
        }
        timeline.push(exit_fullscreen)

        /* start the experiment */
        jsPsych.run(timeline);

    </script>

</body>

</html>