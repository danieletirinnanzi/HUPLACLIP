<!DOCTYPE html>
<html>

<head>
    <title>HUPLACLIP experiment</title>
    <!-- My scripts -->
    <script type="text/javascript" src="graphs_functions.js"></script>
    <script type="text/javascript" src="introduction/introduction_pages_generation.js"></script>
    <script type="text/javascript" src="tutorial/tutorial_pages_generation.js"></script>
    <script type="text/javascript" src="experiment_parameters.js"></script>
    <script type="text/javascript" src="canvas_drawing.js"></script>
    <!-- Standard jspsych.js -->
    <script type="text/javascript" src="jspsych/dist/jspsych.js"></script>
    <!-- Standard plugins -->
    <script type="text/javascript" src="jspsych/dist/plugin-instructions.js"></script>
    <script type="text/javascript" src="jspsych/dist/plugin-image-keyboard-response.js"></script>
    <script type="text/javascript" src="jspsych/dist/plugin-preload.js"></script>
    <!-- Customized plugin -->
    <script type="text/javascript" src="jspsych/dist/my-plugin-canvas-keyboard-response.js"></script>
    <!-- Pavlovia connection (COMMENTED FOR OFFLINE VERSION)
    <script type="text/javascript" src="lib/vendors/jquery-2.2.0.min.js"></script>
    <script type="text/javascript" src="jspsych/dist/my-pavlovia.js"></script>
    -->
    <!-- Styling -->
    <link href="jspsych/dist/jspsych.css" rel="stylesheet" type="text/css" />
</head>

<body style="overflow:hidden">
    <!-- The 'overflow: hidden' css property above prevents scrollbar to be shown on screen -->

    <script type="module">

        /* importing graph pools and extracting the ones that will be shown*/
        let graphsWithCliquePool = await getData('graph_pools/graphs_with_clique_pool.json');
        let graphsWithoutCliquePool = await getData('graph_pools/graphs_without_clique_pool.json');
        // controlling that dimensions of graph pool match experiment parameters (2 graphs per clique size for each block):
        if (currentExperiment.numberOfPresentationsPerBlock / currentExperiment.numberOfGraphsPerCliqueSize != graphsWithCliquePool.length) {
            alert("dimensions of graphs_with_clique pool don't match experiment parameters")
        } else if (currentExperiment.numberOfPresentationsPerBlock / currentExperiment.numberOfGraphsPerCliqueSize != graphsWithoutCliquePool.length) {
            alert("dimensions of graphs_without_clique pool don't match experiment parameters")
        }


        // INSERT IN INDEPENDENT FUNCTION inside "graphs_function.js" (+ DELETE "graphs_generation.js")
        // randomly extracting the graphs that will be shown in each block 
        let maxValue = graphsWithCliquePool[0].length   //this number will be excluded from the extraction
        // empty array that will contain the couples of triangular matrices (objects) to be displayed
        let graphsToDisplay = [];
        // number of blocks:
        for (let blockIndex = 0; blockIndex < currentExperiment.numberOfBlocks; blockIndex++) {
            let graphsForCurrentBlock = []
            // couples of graphs for a single block
            for (let cliqueSizeIndex = 0; cliqueSizeIndex < (currentExperiment.numberOfPresentationsPerBlock / currentExperiment.numberOfGraphsPerCliqueSize); cliqueSizeIndex++) {
                // for each clique size, extracting two couples of graphs: 
                for (let graphIndex = 0; graphIndex < currentExperiment.numberOfGraphsPerCliqueSize; graphIndex++) {
                    // 1. Extracting graph WITH CLIQUE:
                    // randomly extracting index for graph with clique:
                    let randIndex1 = Math.random() * maxValue;
                    randIndex1 = Math.floor(randIndex1);
                    let graphWithClique = graphsWithCliquePool[cliqueSizeIndex][randIndex1]

                    // 2. Extracting graph WITHOUT CLIQUE:
                    // randomly extracting index for graph without clique:
                    let randIndex2 = Math.random() * maxValue;
                    randIndex2 = Math.floor(randIndex2);
                    let graphWithoutClique = graphsWithoutCliquePool[cliqueSizeIndex][randIndex2]

                    // Adding the two graphs to the array for the current trial (random choice of which one is the first in the couple) and pushing this array into the array relative to the current block
                    if (Math.round(Math.random())) {
                        graphsForCurrentBlock.push([graphWithClique, graphWithoutClique])
                    } else {
                        graphsForCurrentBlock.push([graphWithoutClique, graphWithClique])
                    }

                }

            }

            // adding array of graphs for current block to array of all graphs
            graphsToDisplay.push(graphsForCurrentBlock)

        }
        // adding the extracted graphs to the currentExperiment object:
        currentExperiment.graphsToDisplay = graphsToDisplay
        console.log(currentExperiment.graphsToDisplay)


        /* initializing jspsych */
        var jsPsych = initJsPsych({

            on_finish: function (data) {
                // displaying data:
                jsPsych.data.displayData();
                // local save:
                let currentDate = new Date();
                let fileName = `HUPLACLIP_pilot_${currentDate.getDate()}.${(currentDate.getMonth() + 1)}.${currentDate.getFullYear()}_${currentDate.getHours()}.${currentDate.getMinutes()}.${currentDate.getSeconds()}.json`
                jsPsych.data.get().localSave('json', fileName);
            }
        });


        /* create timeline */
        let timeline = [];


        /* init connection with pavlovia.org */
        /*
        var pavlovia_init = {
            type: jsPsychPavlovia,
            command: "init"
        };
        timeline.push(pavlovia_init)


        /* INTRODUCTIVE PAGES */
        /*
        // showing informative pages about the study (informed consent, aim, privacy)
        let introduction = {
            type: jsPsychInstructions,
            pages: generateIntroductionPages(),
            key_forward: "ArrowRight"
        }
        timeline.push(introduction)



        /* INSTRUCTIONS */
        /*
        // PRELOADING instructions images:
        // calling function to create filepaths for all instructions images
        let instructions_ImagesArray = createArrayOfFilePaths(instructionsObject, 0)
        // adding preload plugin to timeline
        let preloadInstructions = {
            type: jsPsychPreload,
            images: instructions_ImagesArray,
        }
        timeline.push(preloadInstructions)

        // SHOWING instructions:
        let instructions = {
            type: jsPsychInstructions,
            pages: generateInstructionsPages(),
            key_forward: "ArrowRight"
        }
        timeline.push(instructions)



        /* AGREEMENT TO MOVE TO TASK FAMILIARIZATION */
        /*
        let move_to_familiarization_form = {
            type: jsPsychInstructions,
            pages: [`<p> Now it's your turn! <br>
                From this moment on, you will not be able to move back and forth through the pages. <br><br>
                Press <b>space</b> to start a <b>trial run of the experiment</b>.<br> (for now, your score will not be recorded) <br>
                </p>`],
            key_forward: " "
        };
        timeline.push(move_to_familiarization_form)



        /* TASK FAMILIARIZATION */
        /*
        // PART 1: WITHOUT BACKGROUND INFORMATION
        // PRELOADING images:
        // calling function to create filepaths for all images
        let taskFamiliarization1_ImagesArray = createArrayOfFilePaths(taskFamiliarizationObject_part1, 1)
        // adding preload plugin to timeline
        let preloadTaskFamiliarization1 = {
            type: jsPsychPreload,
            images: taskFamiliarization1_ImagesArray,
        }
        timeline.push(preloadTaskFamiliarization1)

        // creating the trials for the first part of the task familiarization        
        for (let index = 0; index < Object.keys(taskFamiliarizationObject_part1).length; index += 4) {
            // NB: index increases by 4 at every iteration

            // calling function that generates an array containing a single block of 3 trials (visualization 1, visualization 2, choice)
            let currentBlockOfTrialsArray_part1 = generateBlockOfFamiliarizationTrials(1, index, taskFamiliarizationObject_part1)

            // creating the feedback trial and adding it to the array
            let feedback_trial = {
                type: jsPsychImageKeyboardResponse,
                stimulus: `tutorial/task_familiarization_images/part 1/${taskFamiliarizationObject_part1[index + 4][3]}.PNG`,
                prompt: "", //defined below based on correctness of choice
                choices: [' '],
                stimulus_height: currentExperiment.canvasDimensions[0] / 1.6,
                // using a closure (a function that has access to the variables defined in its outer function) to be able to access "index" from inside the on_start function
                on_start: (function (index) {
                    return function (currentFeedbackTrial) {
                        // accessing last trial:
                        let last_trial = jsPsych.data.get().last(1).values()[0];
                        // changing prompt according to correctness of last choice:
                        if (last_trial.response == taskFamiliarizationObject_part1[index + 4][0].toLowerCase()) {
                            currentFeedbackTrial.prompt = `<br><br><br> ${taskFamiliarizationObject_part1[index + 4][1]}`;
                        } else {
                            currentFeedbackTrial.prompt = `<br><br><br> ${taskFamiliarizationObject_part1[index + 4][2]}`;
                        }
                    };
                })(index)
            };
            currentBlockOfTrialsArray_part1.push(feedback_trial)

            // adding all the elments of the array to the timeline
            currentBlockOfTrialsArray_part1.forEach(singleTrial => {
                timeline.push(singleTrial)
            });

        }


        // PART 2: WITH BACKGROUND INFORMATION
        // PRELOADING images:
        // calling function to create filepaths for all images
        let taskFamiliarization2_ImagesArray = createArrayOfFilePaths(taskFamiliarizationObject_part2, 2)
        // adding preload plugin to timeline
        let preloadTaskFamiliarization2 = {
            type: jsPsychPreload,
            images: taskFamiliarization2_ImagesArray,
        }
        timeline.push(preloadTaskFamiliarization2)

        // creating the trials for the second part of the task familiarization        
        for (let index = 0; index < Object.keys(taskFamiliarizationObject_part2).length; index += 5) {
            // NB: index increases by 5 at every iteration

            // calling function that generates an array containing a single block of 4 trials (visualization 1, visualization 2, choice, solution)
            let currentBlockOfTrialsArray_part2 = generateBlockOfFamiliarizationTrials(2, index, taskFamiliarizationObject_part2)

            // creating the feedback trial and adding it to the array
            let feedback_trial = {
                type: jsPsychImageKeyboardResponse,
                stimulus: "", //defined below based on correctness of choice
                prompt: "", //defined below based on correctness of choice
                choices: [' '],
                // stimulus_width: (SPECIFY IF NECESSARY)
                stimulus_height: currentExperiment.canvasDimensions[0] / 1.6,
                // using a closure (a function that has access to the variables defined in its outer function) to be able to access "index" from inside the on_start function
                on_start: (function (index) {
                    return function (currentFeedbackTrial) {
                        // accessing second to last trial:
                        let second_to_last_trial = jsPsych.data.get().last(2).values()[0];
                        // changing prompt according to correctness of last choice:
                        if (second_to_last_trial.response == taskFamiliarizationObject_part2[index + 5][0].toLowerCase()) {
                            currentFeedbackTrial.stimulus = `tutorial/task_familiarization_images/part 2/${taskFamiliarizationObject_part2[index + 5][3]}.PNG`;
                            currentFeedbackTrial.prompt = `<br><br><br> ${taskFamiliarizationObject_part2[index + 5][1]}`;
                        } else {
                            currentFeedbackTrial.stimulus = `tutorial/task_familiarization_images/part 2/${taskFamiliarizationObject_part2[index + 5][4]}.PNG`;
                            currentFeedbackTrial.prompt = `<br><br><br> ${taskFamiliarizationObject_part2[index + 5][2]}`;
                        }
                    };
                })(index)
            };
            currentBlockOfTrialsArray_part2.push(feedback_trial)

            // adding all the elments of the array to the timeline
            currentBlockOfTrialsArray_part2.forEach(singleTrial => {
                timeline.push(singleTrial)
            });
        }



        /* AGREEMENT TO START EXPERIMENT */
        /*
        // informing that the experiment will start and subject agrees
        // POSSIBLE IMPROVEMENT: use external-HTML plugin (with "agreement_page.html"), so that it is possible to use checkbox and check agreement with a function (alert if clicking something else)
        let consent_form = {
            type: jsPsychInstructions,
            pages: [`<p> You have completed the training: after this page, the real experiment will start and your score will be recorded. <br><br>
               By pressing <b>space</b> you are expressing your consent in taking part in the study, and you confirm to: <br>
             - have carefully read the explanations regarding this study and the full experimental procedure;<br>
             - have been informed regarding the aims of the present research;<br>
             - have had the possibility of asking questions regarding any aspect of the experimental procedure and to have obtained satisfying answers;<br>
             - be aware of the possible risks related with the experiment;<br>
             - have received satisfying assurance regarding the confidentiality of the information collected through the testing of your data;<br>
             - be aware that you can withdraw in any phase of the study.<br><br> 
             Press <b>space</b> to start the experiment.
             </p>`],
            key_forward: " "
        };
        timeline.push(consent_form)



        /* ACTUAL EXPERIMENT: */

        /* DRAWING STIMULI: */
        // FUNCTION THAT WILL DRAW THE STIMULI GIVEN THE CHOSEN ORDER OF THE NODES:
        function generateDrawCanvas(blockIndex, presentationIndex) {
            /* INPUT: 
            - presentationIndex (the number that identifies the couple of graphs that is being displayed)

            OUTPUT:
            - display of the stimuli on the screen
            */

            // function that generates the stimuli:
            function drawCanvas(c) {

                // addressing canvas
                let ctx = c.getContext("2d");

                // for each presentation, shuffling the standard order of the nodes (used to draw the stimuli)
                let currentTrialOrder = shuffleNodes(currentExperiment.standardOrderOfNodes.slice())    //using "slice()" so that the value of "currentExperiment.standardOrderOfNodes" is not modified)

                // accessing the array of the trials completed up to now (used to draw the feedback):
                let currentTrialsArray = jsPsych.data.get().trials

                // DRAWING ON CANVAS:               
                //left stimulus:
                drawStimulus("left", ctx, blockIndex, presentationIndex, currentTrialOrder)
                // right stimulus:
                drawStimulus("right", ctx, blockIndex, presentationIndex, currentTrialOrder)
                // accuracy and number of remaining randomizations:
                drawFeedback(ctx, blockIndex, presentationIndex, currentTrialsArray)
                // instructions reminder:
                drawInstructionsReminder(ctx)

                // GLOBAL VARIABLES ADDED TO TRIAL_DATA (read in "my-plugin-canvas-keyboard-response.js")
                // order of the nodes (changes from trial to trial)
                jsPsych.data.presentedOrder = currentTrialOrder
                // variables that do not change from trial to trial but are used when subject gives final answer:
                // - correct answer (its value is read to compute the "accuracy" variable)
                if (currentExperiment.graphsToDisplay[blockIndex][presentationIndex][0][currentExperiment.graphSize].clique_array == "clique is absent")
                    //if first stimulus doesn't have the clique, then the graph with the clique (correct answer) is on the right side
                    jsPsych.data.correctResponse = "arrowright"
                else
                    jsPsych.data.correctResponse = "arrowleft"
            }

            return drawCanvas

        }


        // creating the blocks of the experiment
        for (let blockIndex = 0; blockIndex < currentExperiment.numberOfBlocks; blockIndex++) {

            // creating the trials for the block
            for (let presentationIndex = 0; presentationIndex < currentExperiment.numberOfPresentationsPerBlock; presentationIndex++) {

                // defining the current trial
                let currentTrial = {
                    type: jsPsychCanvasKeyboardResponse,
                    canvas_size: [currentExperiment.canvasDimensions[0], currentExperiment.canvasDimensions[1]], // [height,width]
                    choices: [' ', 'ArrowLeft', 'ArrowRight'],
                    response_ends_trial: true,
                    timeline: [],
                    data: {
                        // storing variables that do not change between trials relative to the same couple of graphs
                        // experiment parameters:
                        block_index: blockIndex,
                        presentation_index: presentationIndex,
                        // graphs parameters:
                        clique_size: currentExperiment.arrayOfCliqueSizes[presentationIndex],
                        graph_size: currentExperiment.graphSize,
                        graphs_names: [currentExperiment.graphsToDisplay[blockIndex][presentationIndex][0][currentExperiment.graphSize].graph_name, currentExperiment.graphsToDisplay[blockIndex][presentationIndex][1][currentExperiment.graphSize].graph_name]
                    },
                    on_start: function (currentTrial) {
                        // accessing the data stored up to now (it will increase progressively):
                        let currentData = jsPsych.data.get()
                        // if no more shuffles are available, only allowing final answers (arrow presses):
                        if (currentData.trials.filter(element => element.block_index == blockIndex && element.presentation_index == presentationIndex).length == currentExperiment.maximumNumberOfShuffles)
                            currentTrial.choices = ['ArrowLeft', 'ArrowRight']
                    }
                }

                // adding the stimulus to the timeline of the trial
                // NB: shuffling of nodes is done inside draw function
                currentTrial.timeline.push({ stimulus: generateDrawCanvas(blockIndex, presentationIndex) })

                // repeating the trial until a final answer (left/right arrow press) is given:
                let loop_node = {
                    timeline: [currentTrial],
                    loop_function: function () {
                        // accessing the data stored up to now (it will increase progressively):
                        let currentData = jsPsych.data.get()
                        if (currentData.last(1).values()[0].response == " ") {
                            // if last response was a spacebar press, repeat the trial
                            return true
                        } else if (currentData.last(1).values()[0].response == 0 || currentData.last(1).values()[0].response == 1) {
                            // if last response was on left/right arrow, moving to next trial
                            return false
                        }
                    }
                }

                // adding the loop node to the timeline
                timeline.push(loop_node)

            }

            // after each block, present break page
            switch (blockIndex) {
                // if last block just presented, showing final page
                case (currentExperiment.numberOfBlocks - 1):
                    /* FINAL PAGE */
                    let final_page = {
                        type: jsPsychInstructions,
                        pages: [], // defined inside on_start function (below)
                        key_forward: " ",
                        on_start: function (final_page) {
                            // accessing the array of all the trials completed up to now:
                            let currentTrialsArray = jsPsych.data.get().trials
                            let arrayOfResponses = []
                            currentTrialsArray.forEach(element => {
                                // creating array of all final responses:
                                if (element.hasOwnProperty('accuracy'))
                                    arrayOfResponses.push(element.accuracy)
                            })
                            // calculating accuracy:
                            let numberOfCorrectResponses = arrayOfResponses.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponses = arrayOfResponses.length
                            final_page.pages = [`<p> You completed all the ${currentExperiment.numberOfBlocks} blocks of the experiment. <br>
                                Your overall score was <b> ${numberOfCorrectResponses} / ${numberOfFinalResponses} </b>.<br><br>
                                Thank you for your time.
                                <br><br>
                                Press <b>space</b> to exit.<br>
                                </p>`]
                        }
                    };
                    timeline.push(final_page)
                    break;
                default:
                    /* AGREEMENT TO MOVE TO NEXT BLOCK */
                    let move_to_next_block = {
                        type: jsPsychInstructions,
                        pages: [], // defined inside on_start function (below)
                        key_forward: " ",
                        on_start: function (move_to_next_block) {
                            // accessing the array of the trials completed up to now:
                            let currentTrialsArray = jsPsych.data.get().trials
                            let arrayOfResponsesPerBlock = []
                            currentTrialsArray.forEach(element => {
                                // creating array of final responses for current block:
                                if (element.block_index == blockIndex && element.hasOwnProperty('accuracy'))
                                    arrayOfResponsesPerBlock.push(element.accuracy)
                            })
                            // calculating accuracy:
                            let numberOfCorrectResponsesPerBlock = arrayOfResponsesPerBlock.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponsesPerBlock = arrayOfResponsesPerBlock.length

                            move_to_next_block.pages = [`<p> You completed one block. <br>
                                Your score for this block was <b> ${numberOfCorrectResponsesPerBlock} / ${numberOfFinalResponsesPerBlock} </b>.<br>
                                So far, you have completed <b> ${(blockIndex + 1)} </b> out of <b>${currentExperiment.numberOfBlocks}</b> blocks. <br>
                                You still have <b> ${currentExperiment.numberOfBlocks - (blockIndex + 1)} </b> to go.
                                <br><br>
                                Remember: <br>
                                - Press <b> LEFT / RIGHT arrow </b> to choose the triangle with the hidden red tiles. <br>
                                - Press <b> SPACE </b> to shuffle the triangles. <br><br>
                                When you feel ready, press <b>space</b> to move to the next block.<br>
                                </p>`]
                        }
                    };
                    timeline.push(move_to_next_block)
            }

        }


        /* finish connection with pavlovia.org */
        /*
        var pavlovia_finish = {
            type: jsPsychPavlovia,
            command: "finish",
            participantId: "JSPSYCH-DEMO",

            //NECESSARY WHEN ADDING PROLIFIC:
            //completedCallback: function (){
            //    window.location.replace('https://app.prolific.co/submissions/complete?cc=C180BZKR');
            //},

        };
        timeline.push(pavlovia_finish)


        /* start the experiment */
        jsPsych.run(timeline);

    </script>

</body>

</html>